from Crypto.PublicKey import RSA
from base64 import b64decode
from binascii import b2a_base64

def inverseModulus(a,n):
    t = 0
    newt = 1
    r = n
    newr = a
    while newr != 0:
        quotient = r // newr
        (t, newt) = (newt, t - quotient * newt)
        (r, newr) = (newr, r - quotient * newr)
    if t < 0:
        t += n
    return t

modulus = int("4B41FD66209CD834ED2764F85E3F01BC89A4F49549E08EE523DE45E4665F3AA1F0E3FF8BC4FCDFFAB4C977AA32669A8C05E48D8EDAEADEF2ACA51C5D75212E5285DF8915FA80DB8AA460DB7238C7325079C633B2924FE64CE97F680601B08EC700CA0A12B6AA5D595A2C967E120B6BF17D50A444211320E14943A3C369DC6A9DAB538502AE856EC57EE0E285264B6B2A472B44FF664BEE7BD705F3EBF6DCEC9E9CF5C6F0464736165F15B5185C50E96F7A15A6B7D5BB24F8576181DFDDF32326868F303B866C2F407F217FDB67308B8D3290F04420E6DD95D90E6A5E21D6CA8758AF76CBD85BD583CD9C3B28DE0230778CFCE0F9C9441C738A561BE0976364AB",16)

p = 103878469254262810416178420920886508279443565528381881704977320686750795506024466904649654779519469828071973339352986288730476197807506992531901995791460334963430432338008706969091951712809059992122752232526284372417966893524449337788364793880009083509389836909324378802476939361432267910581951829288568247811
q = modulus/p

phiP = p-1
phiQ = q-1

e = long(65537)

phiN = phiP*phiQ;

# e*d congruente 1 modulo phi(n)

# e*d % phiN == 1;

d = inverseModulus(e,phiN)

dp = d%(p-1)
dq = d%(q-1)
u =  inverseModulus(p,q)

n = p*q;

key = RSA.construct((n,e,d,p,q,u));

f = open('test.pem', 'w')

f.write(key.exportKey('PEM'))

fileToDecrypt = open('gonzalo.diez_RSA_RW.enc','rb').read()